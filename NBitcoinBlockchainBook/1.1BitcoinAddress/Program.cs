using NBitcoin;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BitcoinAddress
{
    public class Program
    {
        static void Main()
        {
            RandomUtils.Random = new UnsecureRandom();

            //===========================================================================================
            //Section. Bitcoin address

            //You know that your Bitcoin Address is what you share to the world to get paid.

            //You probably know that your wallet software uses a private key to spend the money you received on this address.

            //The keys are not stored on the network and they can be generated without access to the Internet.
            //This is how you generate a private key with NBitcoin:

            //Generate a random private key.
            Key privateKey = new Key();

            //From the private key, we use a one-way cryptographic function, to generate a public key.
            PubKey publicKey = privateKey.PubKey;
            Console.WriteLine($"publicKey: {publicKey}");
            //Output:
            //0251036303164f6c458e9f7abecb4e55e5ce9ec2b2f1d06d633c9653a07976560c


            Console.WriteLine(privateKey.GetBitcoinSecret(Network.Main).PubKey.GetType()); 



            //There are two Bitcoin networks:
            //TestNet is a Bitcoin network for development purposes. Bitcoins on this network worth nothing.
            //MainNet is the Bitcoin network everybody uses.
            //Note: You can acquire testnet coins quickly by using faucets. Just google "get testnet bitcoins".


            //You can easily get your bitcoin address from your public key and the network on which this address should be used.
            //Picture depiction:
            //Public key + Network => Bitcoin address

            Console.WriteLine(publicKey.GetAddress(Network.Main));
            //Output:
            //1PUYsjwfNmX64wS368ZR5FMouTtUmvtmTY
            Console.WriteLine("Test"+publicKey.GetAddress(Network.TestNet));
            //Output:
            //n3zWAo2eBnxLr3ueohXnuAa8mTVBhxmPhq

            //Note that a Bitcoin address for mainnet starts with "1", and a Bitcoin address for testnet starts with "m" or "n".

            //To be precise, a Bitcoin address is made up of a version byte which is different on both networks(MainNet, TestNet) and your public key’s hash bytes. Both of these bytes are concatenated and then encoded into a Base58Check format which has an additional 4byte checksum data unlike a Base58 format:
            //Picture depiction:
            //Public key -> Public key hash + Network => Bitcoin address



            //Internally, a public key hash is generated by using a SHA256 cryptographic hash function on the public key, and then a RIPEMD160 cryptographic hash function on the result, using Big Endian notation.
            //Above process can be expressed like this:
            //RIPEMD160(SHA256(publicKey)) or RIPEMD160(SHA256(privateKey.PubKey))

            var publicKeyHash = publicKey.Hash;
            // f6889b21b5540353a29ed18c45ea0031280c42cf
            Console.WriteLine(publicKeyHash); 
            
            //Underlying this statement, publickeyHash(bytes), a version byte are concatenated and then encoded into a Base58Check. 
            var mainNetAddress = publicKeyHash.GetAddress(Network.Main);
            var testNetAddress = publicKeyHash.GetAddress(Network.TestNet);



            //The Base58Check encoding has some neat features, such as checksums to prevent typos and a lack of ambiguous characters such as '0' and 'O'.
            //The Base58Check encoding also provides a consistent way to determine the network of a given address; preventing a wallet from sending MainNet coins to a TestNet address.
            Console.WriteLine(mainNetAddress); // 1PUYsjwfNmX64wS368ZR5FMouTtUmvtmTY
            Console.WriteLine(testNetAddress); // n3zWAo2eBnxLr3ueohXnuAa8mTVBhxmPhq

            var a = privateKey.PubKey.GetAddress(Network.TestNet);
            Console.WriteLine(a);

            var b = a.Network;
            Console.WriteLine(b);
        }
    }
}
