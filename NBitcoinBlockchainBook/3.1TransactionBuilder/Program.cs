using System;
using System.Linq;
using NBitcoin;
using NBitcoin.Stealth;



namespace _3._1TransactionBuilder
{
    class Program
    {
        static void Main()
        {
            //===========================================================================================
            //Using the TransactionBuilder

            //You have seen how the TransactionBuilder works when you have signed your first P2SH and multi-sig transaction.
            //We will see how you can harness its full power, for signing more complicated transactions.
            //With the TransactionBuilder you can:
            //1.Spend any
            //P2PK, P2PKH,
            //multi-sig,
            //P2WPK, P2WSH.
            //2.Spend any P2SH on the previous redeem script.
            //3.Spend Stealth Coin(DarkWallet).
            //4.Issue and transfer Colored Coins(open asset, following chapter).
            //5.Combine partially signed transactions.
            //6.Estimate the final size of an unsigned transaction and its fees.
            //7.Verify if a transaction is fully signed.

            //The goal of the TransactionBuilder is to take Coins and Keys as input, and return back a signed or partially signed transaction.
            //Picture depiction:
            //Coins -> Signed transaction(or it could be a signed transactions) <-Keys.


            //The TransactionBuilder will figure out what Coin to use and what to sign by itself.
            //Do examine TransactionBuilder class containing lots of properties and methods.


            //The usage of the builder is done in four steps:
            //1.You gather the Coins that spent,
            //2.You gather the Keys that you own,
            //3.You enumerate how much Money you want to send to where scriptPubKey indicates,
            //4.You build and sign the transaction,
            //5.Optional: you give the transaction to somebody else, then he will sign or continue to build it.


            //Now let’s gather some Coins. 
            //For that, let us create a fake transaction with some funds on it.
            //Let’s say that the transaction has a P2PKH, P2PK, and multi-sig coin of Bob and Alice.
            RandomUtils.Random = new UnsecureRandom();
            var bob = new Key();
            var alice = new Key();

            Script bobAlice =
                PayToMultiSigTemplate.Instance.GenerateScriptPubKey(2, bob.PubKey, alice.PubKey);

            //This transaction will send money to Bob and Alice.
            //The thing you should notice is that this transaction includes various types of scriptPubKey, such as P2PK(generated by bob.PubKey), P2PKH(generated by alice.PubKey.Hash), and multi-publicKey(generated by bobAlice).
            var init = new Transaction();
            init.Outputs.Add(new TxOut(Money.Coins(1m), bob.PubKey)); // P2PK
            init.Outputs.Add(new TxOut(Money.Coins(1m), alice.PubKey.Hash)); // P2PKH
            init.Outputs.Add(new TxOut(Money.Coins(1m), bobAlice));

            //Now let’s say they want to use the coins of this transaction to pay Satoshi.
            var satoshi = new Key();

            //First they have to get their Coins.
            //Get the coins from the initial transaction which contains their UTXOs.
            Coin[] coins = init.Outputs.AsCoins().ToArray();

            Coin bobCoin = coins[0];
            Coin aliceCoin = coins[1];
            Coin bobAliceCoin = coins[2];

            //Now let’s say bob wants to sends 0.2 BTC, alice 0.3 BTC, and they agree to use bobAlice to send 0.5 BTC.
            //Build the transaction by using features of the TransactionBuilder class.
            var builder = new TransactionBuilder();
            Transaction tx = builder
                    .AddCoins(bobCoin)
                    //PriveteKey of Bob to be used for signing.
                    .AddKeys(bob)
                    .Send(satoshi, Money.Coins(0.2m))
                    .SetChange(bob)
                    .Then()
                    .AddCoins(aliceCoin)
                    .AddKeys(alice)
                    .Send(satoshi, Money.Coins(0.3m))
                    .SetChange(alice)
                    .Then()
                    .AddCoins(bobAliceCoin)
                    .AddKeys(bob, alice)
                    .Send(satoshi, Money.Coins(0.5m))
                    .SetChange(bobAlice)
                    .SendFees(Money.Coins(0.0001m))
                    .BuildTransaction(sign: true);
            Console.WriteLine(tx);

            //Then you can verify it is fully signed and ready to send to the network.
            //Verify you did not screw up.
            Console.WriteLine(builder.Verify(tx)); // True



            //============================================================================================
            //Do with ScriptCoin.

            //The nice thing about this model is that it works the same way for P2SH, P2WSH, P2SH(P2WSH), and P2SH(P2PKH) except you need to create ScriptCoin.

            //Picture depection:
            //Coin-> ScriptCoin <-RedeemScript.

            init = new Transaction();
            init.Outputs.Add(new TxOut(Money.Coins(1.0m), bobAlice.Hash));

            coins = init.Outputs.AsCoins().ToArray();
            ScriptCoin bobAliceScriptCoin = coins[0].ToScriptCoin(bobAlice);

            //Then the signature:
            builder = new TransactionBuilder();
            tx = builder
                    .AddCoins(bobAliceScriptCoin)
                    .AddKeys(bob, alice)
                    .Send(satoshi, Money.Coins(0.9m))
                    .SetChange(bobAlice.Hash)
                    .SendFees(Money.Coins(0.0001m))
                    .BuildTransaction(true);
            Console.WriteLine(builder.Verify(tx)); // True


            //============================================================================================
            //Do with a StealthCoin.

            //For Stealth Coin, this is basically the same thing. Except that, if you remember our introduction on Dark Wallet, I said that you need a ScanKey to see the StealthCoin.

            //Picture depection:
            //ScanKey + Transaction + StealthAddress => StealthCoin.

            //Let’s create darkAliceBob stealth address as in previous chapter:

            Key scanKey = new Key();
            BitcoinStealthAddress darkAliceBob =
                new BitcoinStealthAddress
                    (
                        scanKey: scanKey.PubKey,
                        pubKeys: new[] { alice.PubKey, bob.PubKey },
                        signatureCount: 2,
                        bitfield: null,
                        network: Network.Main
                    );


            //Let’s say someone sent the coin to this transaction via the darkAliceBob which is a BitcoinStealthAddress:
            init = new Transaction();
            darkAliceBob
                .SendTo(init, Money.Coins(1.0m));

            //The scanner will detect the StealthCoin:
            //Get the stealth coin with the scanKey.
            StealthCoin stealthCoin
                = StealthCoin.Find(init, darkAliceBob, scanKey);

            //And forward it to Bob and Alice, who will sign:
            //Let Bob and Alice sign and spend the coin.
            tx = builder
                    .AddCoins(stealthCoin)
                    .AddKeys(bob, alice, scanKey)
                    .Send(satoshi, Money.Coins(0.9m))
                    .SetChange(bobAlice.Hash)
                    .SendFees(Money.Coins(0.0001m))
                    .BuildTransaction(true);
            Console.WriteLine(builder.Verify(tx)); // True
            //Note: You need the scanKey for spending a StealthCoin
        }
    }
}
