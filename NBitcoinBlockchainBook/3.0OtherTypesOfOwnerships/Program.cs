//===========================================================================================
//

using System;
using System.Numerics;
using System.Linq;
using System.Text;
using NBitcoin;
using NBitcoin.Crypto;

namespace _3._0OtherTypesOfOwnerships
{
    class Program
    {
        static void Main()
        {
            RandomUtils.Random = new UnsecureRandom();

            //===========================================================================================
            //Part. Other types of ownership
            //I will briefly talk about each type of ScriptPubKey that you are likely to see on the blockchain. Then I will explain how simple it is to sign each type of ScriptPubKey in the last part of the chapter “Using the TransactionBuilder”.






            //===========================================================================================
            //Chapter. P2PK[H] (Pay to Public Key [Hash])



            //===========================================================================================
            //Section1. P2PKH - Quick recap
            //Pay To Public Key Hash

            //We learned that a Bitcoin address is generated by a public key hash and a network identifier.

            var publicKeyHash = new Key().PubKey.Hash;
            var bitcoinAddress = publicKeyHash.GetAddress(Network.Main);
            Console.WriteLine(publicKeyHash);
            //Output:
            //41e0d7ab8af1ba5452b824116a31357dc931cf28
            Console.WriteLine(bitcoinAddress);
            //Output:
            //171LGoEKyVzgQstGwnTHVh3TFTgo5PsqiY


            //The Blockchain identifies a receiver with a ScriptPubKey. And such ScriptPubKey could be generated from a Bitcoin address.
            var scriptPubKey = bitcoinAddress.ScriptPubKey;
            Console.WriteLine(scriptPubKey);
            //Output:
            //OP_DUP OP_HASH160 41e0d7ab8af1ba5452b824116a31357dc931cf28 OP_EQUALVERIFY OP_CHECKSIG

            //And vice versa. a Bitcoin address could be generated from a ScriptPubKey, but along with a network identifier.
            var sameBitcoinAddress = scriptPubKey.GetDestinationAddress(Network.Main);
            Console.WriteLine($"sameBitcoinAddress {sameBitcoinAddress}");



            //==========================================================================================
            //Section2. P2PK
            //Pay To Public Key

            //However, not all ScriptPubKey represents a Bitcoin address. For example, the ScriptPubKey in the first transaction in the first ever blockchain block called the genesis block doesn't represent a Bitcoin address. In other words, the first ScriptPubKey ever in the genesis block represents null as a Bitcoin address.

            Block genesisBlock = Network.Main.GetGenesis();
            Transaction firstTransactionEver = genesisBlock.Transactions.First();
            Console.WriteLine(firstTransactionEver);
            //{
            //…
            //  "out": [
            //    {
            //      "value": "50.00000000",
            //      "scriptPubKey": "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f OP_CHECKSIG"
            //    }
            //  ]
            //}



            var firstOutputEver = firstTransactionEver.Outputs.First();
            var firstScriptPubKeyEver = firstOutputEver.ScriptPubKey;
            Console.WriteLine(firstScriptPubKeyEver);
            //Output:
            //04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f OP_CHECKSIG


            var firstBitcoinAddressEver = firstScriptPubKeyEver.GetDestinationAddress(Network.Main);
            Console.WriteLine(firstBitcoinAddressEver == null);
            //Output:
            //True


            //You can see that the form of the ScriptPubKey is different from above output of the ScriptPubkey?

            //A Bitcoin address is ordinarily represented by:
            //OP_DUP OP_HASH160 <hash> OP_EQUALVERIFY OP_CHECKSIG

            //But here we have:
            //<pubkey> OP_CHECKSIG

            //It's because, In fact, at the beginning, public keys were used directly in the ScriptPubKey.
            var firstPubKeyEver = firstScriptPubKeyEver.GetDestinationPublicKeys().First();
            Console.WriteLine(firstPubKeyEver);
            //Output:
            //04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f



            //Now we are mainly using the hash of the public key.
            //Note that how P2PK and P2PKH work with a private key, a public key, a public key hash, and a ScriptPubKey.
            //P2PK : PrivateKey->Public Key<->ScriptPubKey.
            //P2PKH : PrivateKey->Public Key->Public Key hash<->ScriptPubKey.

            var privateKey = new Key();
            Console.WriteLine("Pay To Public Key : " + privateKey.PubKey.ScriptPubKey);
            Console.WriteLine("Pay To Public Key Hash : " + privateKey.PubKey.Hash.ScriptPubKey);
            //Output:
            //02fb8021bc7dedcc2f89a67e75cee81fedb8e41d6bfa6769362132544dfdf072d4 OP_CHECKSIG
            //Output:
            //OP_DUP OP_HASH160 0ae54d4cec828b722d8727cb70f4a6b0a88207b2 OP_EQUALVERIFY OP_CHECKSIG

            //            These 2 types of payment are referred as P2PK (pay to public key) and P2PKH(pay to public key hash).

            //Satoshi later decided to use P2PKH instead of P2PK for two reasons:

            //Elliptic Curve Cryptography(the cryptography used by your public key and private key) is vulnerable to a modified Shor's algorithm for solving the discrete logarithm problem on elliptic curves. In plain English, it means that in the future a quantum computer might be able to retrieve a private key from a public key. By publishing the public key only when the coins are spent (and assuming that addresses are not reused), such an attack is rendered ineffective.
            //With the hash being smaller(20 bytes) it is easier to print and easier to embed into small storage mediums like QR codes.
            //Nowadays, there is no reason to use a P2PK directly although it is still used in combination with a P2SH... And more on this later.


            //(Discussion) If the issue of the early use of P2PK is not addressed it will have a serious impact on the Bitcoin price.

            //Exercise
            //(nopara73) While reading this chapter I found the abbreviations (P2PK, P2PKH, P2W, etc..) very confusing.
            //My trick was to force myself to pronounce the terms fully every time I encountered them during the following lessons. Suddenly everything made much more sense. I recommend you to do the same.



            //============================================================================================

            //Chapter. P2WPKH(Pay to Witness Public Key Hash)

            //            In 2015, Pieter Wuille introduced a new feature to bitcoin called Segregated Witness, also known by it's abbreviated name, Segwit. Basically, Segregated Witness moves the proof of ownership from the scriptSig part of the transaction to a new part called the witness of the input.

            //There are several reasons why it is beneficial to use this new scheme, a summary of which are presented below.For more details visit https://bitcoincore.org/en/2016/01/26/segwit-benefits/.

            //            Third party Malleability Fix: Previously, a third party could change the transaction id of your transaction before it was confirmed.This can not occur under Segwit.
            //Linear sig hash scaling: Signing a transaction used to require hashing the whole transaction for every input. This was a potential DDoS vector attack for large transactions.
            //Signing of input values: The amount that is spent in an input is also signed, meaning that the signer can’t be tricked about the amount of fees that are actually being paid.
            //Capacity increase: It will now be possible to have more than 1MB of transactions in each block(which are created every 10 minutes on average).Segwit increases this capacity by a factor of about 2.1, based upon the average transaction profile from November 2016.
            //Fraud proof: Will be developed later, but SPV wallets will be able to validate more consensus rules rather than just simply following the longest chain.
            //Before Sewgit the transaction signature was used in the calculation of the transaction id.




            //The signature contains the same information as a P2PKH spend, but is located in the witness instead of the scriptSig. The scriptPubKey though, is modified from

            //OP_DUP OP_HASH160 0067c8970e65107ffbb436a49edd8cb8eb6b567f OP_EQUALVERIFY OP_CHECKSIG
            //To
            //0 0067c8970e65107ffbb436a49edd8cb8eb6b567f



            //For nodes which did not upgrade, this looks like two pushes on the stack.This means that any scriptSig can spend them. So even without the signatures, old nodes will consider such transactions valid.New nodes interpret the first push as the witness version and the second push as the witness program.
            //New nodes will therefore also require the signature in order to verify the transaction.
            //In NBitcoin, spending a P2WPKH output is no different from spending a normal P2PKH.
            //To get the ScriptPubKey from a public key simply use PubKey.WitHash instead of PubKey.Hash.

            var key1 = new Key();
            var scriptPubKeyForSegwit = key1.PubKey.WitHash.ScriptPubKey;
            Console.WriteLine($"scriptPubKeyForSegwit: {scriptPubKeyForSegwit}");
            //Output:
            //0 a16aa39fa2f15759f300f2f146331b053834e913



            //Signing the spending of such coins will be explained later in the “Using the TransactionBuilder" section, and does not differ in any way from the code used to sign a P2PKH output.

            //The witness data is similar to the scriptSig of P2PKH, and the scriptSig data is empty:


            // "in": [
            // {
            // "prev_out": 
            // {
            // "hash": "725497eaef527567a0a18b310bbdd8300abe86f82153a39d2f87fef713dc8177",
            // "n": 0
            // },
            // "scriptSig": "",
            // "witness": "3044022079d443be2bd39327f92adf47a34e4b6ad7c82af182c71fe76ccd39743ced58cf0220149de3e8f11e47a989483f371d3799a710a7e862dd33c9bd842c417002a1c32901 0363f24cd2cb27bb35eb2292789ce4244d55ce580218fd81688197d4ec3b005a67"
            // }

            //Once again, the semantics of P2WPKH is the same as the semantics of P2PKH, except that the signature is not placed at the same location as before.







            //=========================================================================================
            //Chapter3. Multi-Sig

            //It is possible to have shared ownership and control over coins.

            //In order to demonstrate this we will create a ScriptPubKey that represents an m - of - n multi sig. This means that in order to spend the coins, m number of private keys will need to sign the spending transaction out of the n number of different public keys provided.

            //Let’s create a multi sig with Bob, Alice and Satoshi, where two of the three of them need to sign a transaction in order to spend a coin.

            //Private key generator.

            Key privateKeyGenerator = new Key();
            BitcoinSecret bitcoinSecretFromPrivateKeyGenerator = privateKeyGenerator.GetBitcoinSecret(Network.Main);
            Key privateKeyFromBitcoinSecret = bitcoinSecretFromPrivateKeyGenerator.PrivateKey;
            Console.WriteLine($"privateKeyFromBitcoinSecret.ToString(Network.Main): {privateKeyFromBitcoinSecret.ToString(Network.Main)}");
            //L5DZpEdbDDhhk3EqtktmGXKv3L9GxttYTecxDhM5huLd82qd9uvo is for Alice
            //KxMrK5EJeUZ1z3Jyo2zPkurRVtYFefab4WQitV5CyjKApHsWfWg9 is for Bob
            //KyStsAHgSehHvewS5YfGwhQGfEWYd8qY2XZg6q2M6TqaM8Q8rayg is for Satoshi
            //L2f9Ntm8UUeTLZFv25oZ8WoRW8kAofUjdUdtCq9axCp1hZrsLZja is for Nico

            BitcoinSecret bitcoinSecretForAlice = new BitcoinSecret("L5DZpEdbDDhhk3EqtktmGXKv3L9GxttYTecxDhM5huLd82qd9uvo", Network.Main);
            BitcoinSecret bitcoinSecretForBob = new BitcoinSecret("KxMrK5EJeUZ1z3Jyo2zPkurRVtYFefab4WQitV5CyjKApHsWfWg9", Network.Main);
            BitcoinSecret bitcoinSecretForSatoshi = new BitcoinSecret("KyStsAHgSehHvewS5YfGwhQGfEWYd8qY2XZg6q2M6TqaM8Q8rayg", Network.Main);
            BitcoinSecret bitcoinSecretForNico = new BitcoinSecret("L2f9Ntm8UUeTLZFv25oZ8WoRW8kAofUjdUdtCq9axCp1hZrsLZja", Network.Main);


            Key bobPrivateKey = bitcoinSecretForAlice.PrivateKey;
            Key alicePrivateKey = bitcoinSecretForBob.PrivateKey;
            Key satoshiPrivateKey = bitcoinSecretForSatoshi.PrivateKey;
            Key nicoPrivateKey = bitcoinSecretForNico.PrivateKey;




            Console.WriteLine($"bobPrivateKey.PubKey {bobPrivateKey.PubKey}");
            Console.WriteLine($"alicePrivateKey.PubKey {alicePrivateKey.PubKey}");
            Console.WriteLine($"satoshiPrivateKey.PubKey {satoshiPrivateKey.PubKey}");
            Console.WriteLine($"nicoPrivateKey.PubKey {nicoPrivateKey.PubKey}");
            //03575d9c3bec8dd22fb01aa73e5e8a34b3e305d797df29b9f835e2a69815f085ee
            //0279945c2ef1b89165f7a9ab7703dbf80b4ea7fe7410e63c70886e23a476cfb5dd
            //021b2216a6e5c5a1565f271b0bf9b17a694d207dee53bb28605c43cc8e4ca89467







            var scriptPubKeyByMultiSig = PayToMultiSigTemplate
                .Instance
                .GenerateScriptPubKey(2, new PubKey[]
            {
                bobPrivateKey.PubKey,
                alicePrivateKey.PubKey,
                satoshiPrivateKey.PubKey
            });

            Console.WriteLine(scriptPubKeyByMultiSig);
            //Output:
            //2 0282213c7172e9dff8a852b436a957c1f55aa1a947f2571585870bfb12c0c15d61 036e9f73ca6929dec6926d8e319506cc4370914cd13d300e83fd9c3dfca3970efb 0324b9185ec3db2f209b620657ce0e9a792472d89911e0ac3fc1e5b5fc2ca7683d 3 OP_CHECKMULTISIG
            Console.WriteLine($"scriptPubKeyByMultiSig.Hash: {scriptPubKeyByMultiSig.Hash}");
            //Output:
            //527782d1c58897d8b9edb6ffa788154e4cac8a93


            //As you can see, the scriptPubKeyByMultiSig has the following form: 
            //<sigsRequired> <pubkeys…> <pubKeysCount> OP_CHECKMULTISIG

            //The process for signing it is a little more complicated than just calling Transaction.Sign, which does not work for multi-sig.

            //Later we will talk more deeply about the subject but for now let’s use the TransactionBuilder for signing the transaction.

            //Imagine the multi-sig scriptPubKeyByMultiSig received a coin in a transaction called received:

            var received = new Transaction();
            received.Outputs.Add(new TxOut(Money.Coins(1.0m), scriptPubKeyByMultiSig));


            //Bob and Alice agree to pay Nico 1.0 BTC for his services. 

            //First they get the Coin they received from the transaction.
            //Tip. TxOut + OutPoint(TxID + Index of TxOut) => Coin.
            Coin coin = received.Outputs.AsCoins().First();

            //First get a one Bitcoin address for Nico to which they will send the coin.
            BitcoinAddress nicoBitcoinAddress = nicoPrivateKey.PubKey.GetAddress(Network.Main);

            //Then, with the TransactionBuilder, they create an unsigned transaction.

            TransactionBuilder builder = new TransactionBuilder();
            Transaction unsigned =
                builder
                      .AddCoins(coin)
                      .Send(nicoBitcoinAddress, Money.Coins(1.0m))
                      .BuildTransaction(sign: false);

            //The transaction is not yet signed. Here is how Alice signs it.
            Transaction aliceSigned =
                builder
                    .AddCoins(coin)
                    .AddKeys(alicePrivateKey)
                    .SignTransaction(unsigned);

            //And then Bob.
            Transaction bobSigned =
                 builder
                .AddCoins(coin)
                .AddKeys(bobPrivateKey)
        //At this line, SignTransaction(unSigned) has the identical functionality with the SignTransaction(aliceSigned).
        //It's because unsigned transaction has already been signed by Alice private key from above.
                .SignTransaction(unsigned);

            //Now, Bob and Alice can combine their signature into one transaction. This transaction will then be valid in terms of its signature as Bob and Alice have provided two of the signatures from the three owner signatures that were initially provided. The requirements of the 'two-of-three' multi sig have therefore been met.

            Transaction fullySigned =
                builder
                    .AddCoins(coin)
                    .CombineSignatures(aliceSigned, bobSigned);

            Console.WriteLine(fullySigned);

            //{
            //  ...
            //  "in": [
            //    {
            //      "prev_out": {
            //        "hash": "9df1e011984305b78210229a86b6ade9546dc69c4d25a6bee472ee7d62ea3c16",
            //        "n": 0
            //      },
            //      "scriptSig": "0 3045022100a14d47c762fe7c04b4382f736c5de0b038b8de92649987bc59bca83ea307b1a202203e38dcc9b0b7f0556a5138fd316cd28639243f05f5ca1afc254b883482ddb91f01 3044022044c9f6818078887587cac126c3c2047b6e5425758e67df64e8d682dfbe373a2902204ae7fda6ada9b7a11c4e362a0389b1bf90abc1f3488fe21041a4f7f14f1d856201"
            //    }
            //  ],
            //  "out": [
            //    {
            //      "value": "1.00000000",
            //      "scriptPubKey": "OP_DUP OP_HASH160 d4a0f6c5b4bcbf2f5830eabed3daa7304fb794d6 OP_EQUALVERIFY OP_CHECKSIG"
            //    }
            //  ]
            //}


            //Before sending the transaction to the network, examine the need of CombineSignatures() method.Try to compare a full detail of transaction between bobSigned and fullySigned. It will seem both are identical. For this reason, it seems like the CombineSignatures() method is needless because multi-sig has achieved without the CombineSignatures() method.

            //Let's look at the case that CombineSignatures() is required:


            TransactionBuilder builderNew = new TransactionBuilder();
            TransactionBuilder builderForAlice = new TransactionBuilder();
            TransactionBuilder builderForBob = new TransactionBuilder();

            Transaction unsignedNew =
                            builderNew
                                .AddCoins(coin)
                                .Send(nicoBitcoinAddress, Money.Coins(1.0m))
                                .BuildTransaction(sign: false);


            Transaction aliceSignedNew =
                            builderForAlice
                                .AddCoins(coin)
                                .AddKeys(alicePrivateKey)
                                .SignTransaction(unsignedNew);
            Console.WriteLine(aliceSignedNew);

            Transaction bobSignedNew =
                            builderForBob
                                .AddCoins(coin)
                                .AddKeys(bobPrivateKey)
                                .SignTransaction(unsignedNew);
            Console.WriteLine(bobSignedNew);

            //In this case, the CombineSignatures() method is essentially needed.
            Transaction fullySignedNew =
                            builderNew
                                .AddCoins(coin)
                                .CombineSignatures(aliceSigned, bobSigned);
            Console.WriteLine(fullySignedNew);




            //The transaction is now ready to be sent to the network.

            //Even if the Bitcoin network supports multi sig as explained here, one question worth asking is: How can you expect a user who has no clue about bitcoin to pay using the Alice/ Bob / Satoshi multi - sig as we have done above?

            //Don’t you think it would be cool if we could represent such a scriptPubKey as easily and concisely as a regular Bitcoin Address?

            //Well, this is possible by using something called a Bitcoin Script Address also called Pay To Script Hash or P2SH for short.

            //Nowadays, native Pay To Multi Sig, as you have seen above, and native P2PK are never used directly. Instead they are wrapped into something called a Pay To Script Hash payment.We will look at this type of payment in the next section.






            //========================================================================================
            //Chapter4. P2SH(Pay To Script Hash)

            //As seen in the previous section, using multi-sig is easily done in code. However, before P2SH there was no way to ask someone to pay to a multi-sig scriptPubKey in a way that was as simple as just providing them with a regular Bitcoin address.

            //Pay To Script Hash(or P2SH as it is often known), is an easy way to represent a multi-sig ScriptPubKey as a simple BitcoinScriptAddress, no matter how complicated it is in terms of its underlying m-of-n signature set up.

            //In the previous part we generated this multi-sig:
            //Key bobPrivateKey = new Key();
            //Key alicePrivateKey = new Key();
            //Key satoshiPrivateKey = new Key();

            //var scriptPubKeyByMultiSig = PayToMultiSigTemplate
            //    .Instance
            //    .GenerateScriptPubKey(2, new[] { bobPrivateKey.PubKey, alicePrivateKey.PubKey, satoshiPrivateKey.PubKey });

            //Console.WriteLine(scriptPubKeyByMultiSig);
            //Output:
            //2 0282213c7172e9dff8a852b436a957c1f55aa1a947f2571585870bfb12c0c15d61 036e9f73ca6929dec6926d8e319506cc4370914cd13d300e83fd9c3dfca3970efb 0324b9185ec3db2f209b620657ce0e9a792472d89911e0ac3fc1e5b5fc2ca7683d 3 OP_CHECKMULTISIG



            //Complicated isn’t it?

            //Instead, let’s see how such a scriptPubKeyByMultiSig would look in a P2SH payment.


            //Key bobPrivateKey = new Key();
            //Key alicePrivateKey = new Key();
            //Key satoshiPrivateKey = new Key();

            //Note that PaymentScript property is appended after GenerateScriptPubKey().
            var scriptPubKeyByP2sh = PayToMultiSigTemplate
                .Instance
                .GenerateScriptPubKey(2, new[] { bobPrivateKey.PubKey, alicePrivateKey.PubKey, satoshiPrivateKey.PubKey }).PaymentScript;

            Console.WriteLine($"scriptPubKeyByP2sh: {scriptPubKeyByP2sh}");
            //Output:
            //OP_HASH160 bd888db1f2e9da0f07e80492674e17772aa54122 OP_EQUAL

            //Do you see the difference? This P2SH scriptPubKey represents the hash of the multi-sig ScriptPubKey:
            //redeemScript.Hash.ScriptPubKey


            //Since it is a hash, you can easily convert it to a base58 string BitcoinScriptAddress.
            //Key bobPrivateKey = new Key();
            //Key alicePrivateKey = new Key();
            //Key satoshiPrivateKey = new Key();

            Script redeemScript =
                PayToMultiSigTemplate
                .Instance
                .GenerateScriptPubKey(2, new[] { bobPrivateKey.PubKey, alicePrivateKey.PubKey, satoshiPrivateKey.PubKey });
            Console.WriteLine($"redeemScript.Hash.ScriptPubKey: {redeemScript.Hash.ScriptPubKey}");
            //Output:
            //OP_HASH160 bd888db1f2e9da0f07e80492674e17772aa54122 OP_EQUAL

            Console.WriteLine($"scriptPubKeyByP2sh: {scriptPubKeyByP2sh}");
            //Output:
            //OP_HASH160 bd888db1f2e9da0f07e80492674e17772aa54122 OP_EQUAL

            //The result of above code represents P2SH scriptPubKey generated from redeemScript which is normal scriptPubKey generated by multiple publicKeys.
            
            Console.WriteLine(redeemScript.Hash.GetAddress(Network.Main));
            //Output:
            //3E6RvwLNfkH6PyX3bqoVGKzrx2AqSJFhjo

            //            Such an address will still be understood by any existing client wallet, even if the wallet does not understand what “multi - sig” is.
            //In P2SH payments, we refer to the hash of the Redeem Script as the scriptPubKey.

            Console.WriteLine($"redeemScript.Hash: {redeemScript.Hash}");
            //Output:
            //

            //In other words, Redeem script->Hash of Redeem script->P2SH ScriptPubKey.



            //Since anyone sending a payment to such an address only sees the Hash of the RedeemScript, and do not know the Redeem Script itself, they don’t even have to know that they are sending money to a multi sig of Alice/Bob/Satoshi.
            //Signing such a transaction is similar to what we have done before. The only difference is that you also have to provide the Redeem Script when you build the Coin for the TransactionBuilder.

            //Imagine that the multi-sig P2SH receives a coin in a transaction called received.


           Script redeemScriptPubKeyForP2shPayment =
                 PayToMultiSigTemplate
                 .Instance
                 .GenerateScriptPubKey(2, new[] { bobPrivateKey.PubKey, alicePrivateKey.PubKey, satoshiPrivateKey.PubKey });
            var receivedForP2shPayment = new Transaction();
            //Pay to the script hash which is represented in P2SH scriptPubKey.
            receivedForP2shPayment.Outputs.Add(new TxOut(Money.Coins(1.0m), redeemScriptPubKeyForP2shPayment.Hash));
            //Warning: The payment is sent to redeemScript.Hash and not to redeemScriptPubKeyForP2shPayment!


            //When any two owners out of the three that control the multi-sig address (Alice/Bob/Satoshi) then want to spend what they have received instead of creating a Coin, they will need to create a ScriptCoin.

            //Give the redeemScriptPubKeyForP2shPayment to the coin for Transaction construction and signing.
            //Redeem ScriptPubKey + TxOut + OutPoint => ScriptCoin.
            ScriptCoin scriptCoinForP2shPayment = receivedForP2shPayment.Outputs.AsCoins().First().ToScriptCoin(redeemScriptPubKeyForP2shPayment);



            //The rest of the code concerning transaction generation and signing is exactly the same as in the previous section about native multi-sig.


            //We will send the coin to the above Nico.

            //Create TransactionBuilder.
            TransactionBuilder builderForP2shPayment = new TransactionBuilder();
            TransactionBuilder builderForP2shPaymentForAlice = new TransactionBuilder();
            TransactionBuilder builderForP2shPaymentForBob = new TransactionBuilder();

            Transaction unsignedForP2shPayment =
                builderForP2shPayment
                    .AddCoins(scriptCoinForP2shPayment)
                    .Send(nicoBitcoinAddress, Money.Coins(1.0m))
                    .BuildTransaction(sign: false);

            Transaction aliceSignedForP2shPayment =
                builderForP2shPaymentForAlice
                    .AddCoins(scriptCoinForP2shPayment)
                    .AddKeys(alicePrivateKey)
                    .SignTransaction(unsignedForP2shPayment);

            Transaction bobSignedForP2shPayment =
                builderForP2shPaymentForBob
                    .AddCoins(scriptCoinForP2shPayment)
                    .AddKeys(bobPrivateKey)
                    .SignTransaction(unsignedForP2shPayment);



            Transaction fullySignedForP2shPayment =
                builderForP2shPaymentForBob
                    .AddCoins(scriptCoinForP2shPayment)
                    .CombineSignatures(aliceSignedForP2shPayment, bobSignedForP2shPayment);

            Console.WriteLine($"fullySignedForP2shPayment: {fullySignedForP2shPayment}");





            //==========================================================================================
            //Chapter5. P2WSH(Pay To Witness Script Hash)

            //As with a relationship between a P2PKH and a P2WPKH, likewise, the only difference between a P2SH and a P2WSH is about the location of what was previously in the ScriptSig, and the ScriptPubKey which are being modified.

            //The ScriptPubKey is changed from something like:
            //OP_HASH160 10f400e996c34410d02ae76639cbf64f4bdf2def OP_EQUAL
            //To:
            //0 e4d3d21bab744d90cd857f56833252000ac0fade318136b713994b9319562467

            //That you can print with the following code:
            var privateKeyForP2wsh = new Key();
            var scriptPubKeyForP2wsh = privateKeyForP2wsh.PubKey.ScriptPubKey.WitHash.ScriptPubKey;
            Console.WriteLine($"scriptPubKeyForP2wsh: {scriptPubKeyForP2wsh}");
            //Output:
            //0 276ccb80a72fbd5edc5c3948a1c4aefdbb7264177442635ce2c4639b83c12dd6



            //With what was previously in the scriptSig(signature + redeem script), moved to the witness located in under the script.
            // "in": [
            // {
            // "prev_out": {
            // "hash": "ffa2826ba2c9a178f7ced0737b559410364a62a41b16440beb299754114888c4",
            // "n": 0
            // },
            // "scriptSig": "",
            // "witness": "304402203a4d9f42c190682826ead3f88d9d87e8c47db57f5c272637441bafe11d5ad8a302206ac21b2bfe831216059ac4c91ec3e4458c78190613802975f5da5d11b55a69c601 210243b3760ce117a85540d88fa9d3d605338d4689bed1217e1fa84c78c22999fe08ac"
            // }
            // ]

            //As the P2SH payment explained previously, P2WSH uses ScriptCoin in exactly the same way to be signed.





            //==========================================================================================
            //Chapter6. P2W* over P2SH
            //"P2SH(P2W*)" is equal to "P2W* over P2SH"
            //"P2SH(P2WPKH)" is equal to "P2WPKH over P2SH"


            //While using witness scriptPubKey for your scripting needs is appealing, unfortunately, the reality is that most of nowadays wallets only support "P2PKH" or "P2SH" addresses.

            //To harness the advantages of segwit, with being compatible with old software, "P2W* over P2SH" is allowed. For old nodes, it will look like a normal P2SH payment.

            //You can transform any "P2W*" to a "P2W* over P2SH" by:

            //1.Replacing the ScriptPubKey by its P2SH equivalent.
            //2.The former ScriptPubKey will be placed as the only push in the scriptSig in the spending transaction,
            //3.All other data will be pushed in the witness of the spending transaction.

            //Don’t worry, if this sound complicated, the TransactionBuilder will allow you to abstract the plumbing effectively.

            //Let’s take the example of "P2WPKH over P2SH", also called with the sweet name of "P2SH(P2WPKH)".

            //Printing the ScriptPubKey:
            var privateKeyForP2shP2wpkh = new Key();
            Console.WriteLine(privateKeyForP2shP2wpkh.PubKey.WitHash.ScriptPubKey.Hash.ScriptPubKey);
            Console.WriteLine($"privateKeyForP2shP2wpkh.PubKey.WitHash.ScriptPubKey.Hash.ScriptPubKey:  {privateKeyForP2shP2wpkh.PubKey.WitHash.ScriptPubKey.Hash.ScriptPubKey}");

            //Note: that's quite an awesome line of code.

            //Which gives us a well known P2SH scriptPubKey.
            //OP_HASH160 b19da5ca6e7243d4ec8eab07b713ff8768a44145 OP_EQUAL


            //Then, a signed transaction spending this output will look like:
            // "in": [
            // {
            // "prev_out": {
            // "hash": "674ece694e5e28956138efacab96fc0bffd7c6cc1af7bb2729943fedf8f0b8b9",
            // "n": 0
            // },
            // "scriptSig": "001404100ab485c95701bf0f4d73e3fe7d69ecc4f0ea",
            // "witness": "3045022100f4c14cf383c0c97bbdaf520ea06f7db6c61e0effbc4bd3dfea036a90272f6cce022055b0fc058759a7961e718d48a3dc4dd5580fffc310557925a0865dbe467a835901 0205b956a5afe8f34a01337f0949f5733b5e376caaea57c9624e40e739a0b1d16c"
            // }
            // ],


            //The scriptSig is only the push of the P2SH redeem script of the previous ScriptPubKey which is ,in other words, key.PubKey.WitHash.ScriptPubKey. The witness is exactly the same as a normal P2WPKH payment.

            //In NBitcoin, signing a P2SH(P2WPKH) is exactly similar as signing a normal P2SH with ScriptCoin.

            //By following the same principle, let’s see how a P2SH(P2WSH) looks like. You need to understand that in this case we are dealing with two different redeem scripts: 
            //The P2SH redeem script that need to be put in the scriptSig of the spending transaction, AND the P2WSH redeem script that need to be put in the witness.
            //1.The P2SH redeem script that needs to be put in the scriptSig of the spending transaction,
            //2.And the P2WSH redeem script that needs to be put in the witness.

            //Let’s print the scriptPubKey by following the first rule:

            //1.Replacing the ScriptPubKey by its P2SH equivalent.
            var privateKeyForP2shP2wpkhEx = new Key();
            Console.WriteLine(privateKeyForP2shP2wpkhEx.PubKey.ScriptPubKey.WitHash.ScriptPubKey.Hash.ScriptPubKey);
            //OP_HASH160 d06c0058175952afecc56d26ed16558b1ed40e42 OP_EQUAL




            //2.The former ScriptPubKey will be placed as the only push in the scriptSig in the spending transaction.

            //3.All other data will be pushed in the witness of the spending transaction.

            //Result of input.
            //"in": [
            //  {
            //    "prev_out": {
            //      "hash": "1d23fa744a26cf6433f0841e9de7e088cf95e6f953e584b98d0de6ef4216765f",
            //      "n": 0
            //    },
            //    "scriptSig": "0020c54eb79829b2e26b71d15fd3b490b6e95cbdab361a45eed2cdfe642497480a6c",
            //    "witness": "3045022100d7570c3bf87149a0be3ba2e8bfccbdd35c3da44f741695e9962014795fabc4fc02203183cfa55a85728520b0f1ac59ac3ffa1a8526634fe619f99fac0f76016f366e01 2103146e87d7fcc81f3e044f97c6b262c01826f40a9ab9acae0f689983a5890a1f4dac"
            //  }
            //],



            //In summary, the P2SH Redeem Script is hashed to get the P2WSH scriptPubKey as normal P2WSH payment. Then, as in a normal P2SH payment, the P2WSH scriptPubKey is replaced by hashed one of the P2WSH scriptPubKey, and the hashed one is used to create the actual P2SH.

            //If P2SH/ P2WSH / P2SH(P2WSH) / P2SH(P2WPKH) sounds complicated to you, fear not.
            //NBitcoin, for all of those payment types, only requires you to create a ScriptCoin by supplying the Redeem(P2WSH redeem or P2SH redeem) and the ScriptPubKey, exactly as explained in the P2SH part.


            //As far as NBitcoin is concerned, you just need to feed the right transaction output you want to spend, with the right underlying redeem script, and the TransactionBuilder will figure out how to sign correctly as explained in the previous Multi Sig part and the next “Using the TransactionBuilder” part.

            //Illustration:
            //Redeem script + TxOut + OutPoint => ScriptCoin

            //Compatible for P2SH/P2WSH/P2SH(P2WSH)/P2SH(P2WPKH)
            //You can browse additional examples of P2W* payments on http://n.bitcoin.ninja/checkscript





            //=========================================================================================
            //Chapter7. Arbitrary

            //From Bitcoin 0.10, the RedeemScript can be arbitrary, which means that with the script language of Bitcoin, you can create your own definition of what “ownership” means.

            //For example, in this scheme, I can be given money from whoever either knows my date of birth (dd/mm/yyyy) serialized in UTF-8 or the Bitcoin address of this book, 1KF8kUVHK42XzgcmJF4Lxz4wcL5WDL97PB.

            //The details of the script language are out of scope. You can easily find the documentation for the Bitcoin script language on various websites. And it is a stack based language so everyone having done with some assembler should be able to read it.

            //Note: (nopara73) I find Davide De Rosa's tutorial as the most enjoyable one.

            //So first, let’s build the RedeemScript,

            //Note: For this code to work right, Click References ->** Add Reference...** -> Find System.Numerics


            BitcoinAddress bitcoinAddressOfThisBook = BitcoinAddress.Create("1KF8kUVHK42XzgcmJF4Lxz4wcL5WDL97PB");
            var birthDay = Encoding.UTF8.GetBytes("18/07/1988");
            var birthDayHash = Hashes.Hash256(birthDay);
            var redeemScriptForSendingCoinToBook = new Script(
                            "OP_IF "
                                + "OP_HASH256 " + Op.GetPushOp(birthDayHash.ToBytes()) + " OP_EQUAL " +
                            "OP_ELSE "
                                + bitcoinAddressOfThisBook.ScriptPubKey + " " +
                            "OP_ENDIF");



            //This RedeemScript means that there is 2 way of spending such ScriptCoin: 
            //This can be spent in either case you know the data(birthDay) that can generate birthDayHash, or you own the Bitcoin address.

            //Let’s say I sent money to such redeemScript:
            var txForSendingCoinToBook = new Transaction();
            txForSendingCoinToBook.Outputs.Add(new TxOut(Money.Parse("0.0001"), redeemScriptForSendingCoinToBook.Hash));
            var scriptCoinForSendingCoinToBook = txForSendingCoinToBook.Outputs.AsCoins().First().ToScriptCoin(redeemScriptForSendingCoinToBook);



            //So let’s create a transaction that wants to spend such output.
            //Create spending transaction
            Transaction txSpendingCoinOfThisBook = new Transaction();
            txSpendingCoinOfThisBook.AddInput(new TxIn(new OutPoint(txForSendingCoinToBook, 0)));

            //The first option is to know my birth date and to prove it in the scriptSig.
            //Option 1 : Spender knows my birthdate.
            Op pushBirthdate = Op.GetPushOp(birthDay);
            //Go to IF
            Op selectIf = OpcodeType.OP_1; 
            Op redeemBytes = Op.GetPushOp(redeemScriptForSendingCoinToBook.ToBytes());
            Script scriptSig = new Script(pushBirthdate, selectIf, redeemBytes);
            txSpendingCoinOfThisBook.Inputs[0].ScriptSig = scriptSig;

            //You can see that in the scriptSig I push OP_1 so I enter in the OP_IF of my redeemScriptForSendingCoinToBook.
            //Since there is no backed -in template, for creating such scriptSig, you can see how to build a P2SH scriptSig by hand.

            //Then you can check that the scriptSig prove the ownership of the scriptPubKey:

            //Verify if the script is passed.
            var result = txSpendingCoinOfThisBook
                           .Inputs
                           .AsIndexedInputs()
                           .First()
                           .VerifyScript(txForSendingCoinToBook.Outputs[0].ScriptPubKey);
            //Output:
            //True
            Console.WriteLine(result);

            //The second way of spending the coin is by proving ownership of the Bitcoin address, 1KF8kUVHK42XzgcmJF4Lxz4wcL5WDL97PB.
            //Option 2 : Spender knows my private key related to the Bitcoin address, 1KF8kUVHK42XzgcmJF4Lxz4wcL5WDL97PB.
            BitcoinSecret privateKeyRelatedToTheBookBitcoinAddress = new BitcoinSecret("PrivateKeyRepresentedInBase58StringRelatedToTheBookBitcoinAddress");
            //var sig = spending.SignInput(privateKeyRelatedToTheBookBitcoinAddress, scriptCoinForSendingCoinToBook);
            //var p2pkhProof = PayToPubkeyHashTemplate
            //    .Instance
            //    .GenerateScriptSig(sig, secret.PrivateKey.PubKey);
            //selectIf = OpcodeType.OP_0; //go to else
            //scriptSig = p2pkhProof + selectIf + redeemBytes;
            //spending.Inputs[0].ScriptSig = scriptSig;




            //And ownership is also proven:
            //Verify the script pass
            result = txSpendingCoinOfThisBook
                            .Inputs
                            .AsIndexedInputs()
                            .First()
                            .VerifyScript(txForSendingCoinToBook.Outputs[0].ScriptPubKey);
            Console.WriteLine(result);

            Console.ReadLine();
        }
        
    }
}
